# ShadowChrome

ShadowChrome is an ambitious experiment to create a secure communication channel directly inside the browser. The extension consumes a single `ss://` or `ssconf://` key, contacts the public Shadowsocks ecosystem to discover available endpoints, and then performs all remaining work within Chrome. By avoiding native helpers and relying solely on the MV3 environment, ShadowChrome aims to make encrypted browsing transparent, portable and easy to audit.

The project itself is authored by artificial intelligence. In 2025 its code generation is powered by GPT‑5, exploring a zero‑coding workflow where detailed technical descriptions are translated directly into working code, allowing complex programs to be assembled without manual implementation.

> **Status:** The legacy Node.js helper server has been removed. The service worker parses configuration links, configures Chrome's proxy settings and now hosts a fully functional `chrome.sockets` Shadowsocks client with AES‑256‑GCM encryption.

## Philosophy
ShadowChrome is guided by a few core ideas that shape its development:

- **Freedom and privacy.** The project exists to provide a convenient way to reclaim a private connection without installing opaque system-wide tools.
- **Transparency.** Every line of code runs inside an extension that can be inspected, rebuilt and modified by the community.
- **Self-reliance.** All logic executes in the browser; no native daemons or external proxy processes are required.
- **Simplicity.** Connecting should be as straightforward as pasting a link and clicking a button, making censorship-resistant browsing approachable for newcomers.
- **Zero-coding vision.** ShadowChrome's codebase is generated by AI from clear task descriptions, demonstrating how sophisticated software can emerge from high-quality specifications.

These principles influence both the current architecture and the long-term roadmap.

## Installation
1. Navigate to `chrome://extensions/` and enable **Developer mode** so Chrome allows running unpacked extensions.
2. Click **Load unpacked** and choose the `src` directory that contains the manifest and scripts.

## Usage
1. Click the ShadowChrome icon to open the popup interface. A compact header exposes a quick language selector and a gear button that jumps straight to the full settings surface.
2. Paste an `ss://` or `ssconf://` access key and press **Import access key**. ShadowChrome stores every server exposed by the subscription and collapses the input field so the popup can concentrate on location selection.
3. If multiple servers are returned, the location picker sorts them by the fastest reported latency. Choose an entry and press **Connect**. The extension persists the configuration and points Chrome's proxy to the locally hosted Shadowsocks client (`127.0.0.1:1080`).
4. Press **Disconnect** to clear the proxy configuration and return Chrome to its previous state.
5. Use the gear-labelled **Settings** button to adjust languages, manage CensorTracker domains, control Outline managers, or run diagnostics on the dedicated options page.
6. When a direct connection attempt fails, ShadowChrome automatically requests fresh fallback servers from the CensorTracker network and retries with those endpoints before surfacing an error.

> Before sharing the project with others or relying on it in the field, review the experimental-use expectations in [`docs/USAGE_POLICY.md`](docs/USAGE_POLICY.md).

## Development
The project embraces openness and encourages experimentation. Developers can explore the source code and contribute enhancements without leaving the JavaScript ecosystem.

- All extension code resides in `src/` and uses modern ES modules.
- Run `npm install` once to set up linting and dependencies.
- Execute `npm run lint` to check code style.

## Architecture
The extension is intentionally simple. Each module has a narrow responsibility that can be reasoned about independently:

- `popup.html` / `popup.js` provide a compact connection UI focused on importing keys, picking a location, and starting or stopping the proxy.
- `options.html` / `options.js` host the full management console with language selection, registry controls, saved servers, Outline manager tooling, and diagnostics.
- `ssConfig.js` parses `ss://` and `ssconf://` URLs using the Outline access-key parser and expands subscription links into concrete server configurations.
- `registry.js` merges upstream CensorTracker domains, custom overrides, and ignore rules before regenerating the PAC script.
- `censortrackerServer.js` mirrors the upstream CensorTracker synchronization workflow inside the extension and caches fallback Shadowsocks endpoints supplied by CensorTracker.
- `background.js` (service worker) applies proxy settings and runs a full Shadowsocks client using `chrome.sockets`.

For a deep dive into workflow and implementation details, see [`docs/DETAILED_DOCUMENTATION.md`](docs/DETAILED_DOCUMENTATION.md).
For module-by-module guidance and runtime flow diagrams, start with
[`docs/architecture/README.md`](docs/architecture/README.md).

## User Guide

The popup experience, Outline Manager integration, and troubleshooting steps are documented in detail in [`docs/USER_GUIDE.md`](docs/USER_GUIDE.md).

## Localized documentation

- [README.ru.md](README.ru.md) — Russian translation of this overview.

## License
[MIT](LICENSE).
<!-- Updated: 2025-10-01 -->
