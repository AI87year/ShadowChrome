# ShadowChrome — подробная документация

## Общее представление
ShadowChrome — это расширение Chrome, которое поднимает полноценный клиент Shadowsocks прямо в браузере. Пользователю достаточно предоставить URL `ss://` или `ssconf://`, а остальное расширение сделает само: разберет конфигурацию, подберет сервер и настроит прокси Chrome. Весь протокол реализован в сервис-воркере через `chrome.sockets`, поэтому отдельные нативные процессы не нужны.

## Для кого этот документ
Файл адресован разработчикам, ревьюерам и любознательным тестировщикам, которым важно понимать внутреннее устройство проекта. Если вам нужно просто подключиться, начните с практического руководства [`docs/USER_GUIDE.ru.md`](USER_GUIDE.ru.md).

Документация состоит из нескольких взаимосвязанных уровней:

- **`USER_GUIDE.ru.md`** — пошаговые сценарии и советы по ежедневному использованию.
- **`DETAILED_DOCUMENTATION.ru.md`** — общий обзор архитектуры и зон ответственности модулей.
- **`docs/architecture/`** — диаграммы, последовательности и подробные разборы компонентов.
- **`USAGE_POLICY.md`** — требования к допустимому использованию и напоминание, что проект носит экспериментальный характер (документ доступен на английском).

Во время онбординга просмотрите этот файл, чтобы сложить общую картину, а затем переходите к архитектурным материалам за деталями.

## Зачем создан проект
ShadowChrome вырос из исследования того, насколько далеко можно зайти в браузерной платформе, не прибегая к нативному коду. Классические прокси-клиенты требуют установки привилегированных бинарников, что неудобно в контролируемых средах. ShadowChrome снижает порог входа за счет открытого кода, который работает прямо в песочнице Chrome. В связке с распределенной сетью Shadowsocks расширение дает портативный способ вернуть приватный канал связи.

Проект также демонстрирует «нулевое программирование»: расширение спроектировано и создано при участии искусственного интеллекта. Подробные технические описания напрямую превращаются в рабочий код, что показывает, как сложные приложения могут появляться без ручного написания каждой строки. За разборами по модулям загляните в каталог [`docs/architecture/`](architecture/).

Главная идея — прозрачность. Все компоненты написаны на JavaScript и HTML, поэтому любой желающий может изучить, изменить или пересобрать проект без специальных инструментов.

### Основные принципы
Каждое инженерное решение опирается на несколько правил:

1. **Только браузер.** Вся логика живет в окружении Manifest V3. Никаких нативных бинарников или фоновых демонов, поэтому разворачивать расширение можно даже в ограниченных средах.
2. **Проверяемость.** Модули получаются небольшими и связными. Поведение легко проследить от клика в интерфейсе до действия сервис-воркера.
3. **Доступность и локализация.** Интерфейсы используют ARIA-хуки, а языковой переключатель держит всплывающее окно и страницу параметров в синхронизации.
4. **Исследовательский статус.** ShadowChrome — эксперимент, а не готовый инструмент для обхода блокировок. Подробнее — в [`USAGE_POLICY.md`](USAGE_POLICY.md).

## Цели

- **Автономность.** Запускаться в среде MV3 без вспомогательных сервисов, уменьшая поверхность атаки и упрощая развертывание.
- **Простой UX.** Пользователь вставляет URL, нажимает «подключиться», а расширение берет на себя остальную работу.
- **Гибкая конфигурация.** Поддержка одиночных ссылок и подписок, чтобы один access key можно было переносить между устройствами.
- **Понятная документация.** Многоуровневые материалы помогают перейти от пользовательского сценария к глубокому разбору без чтения всего кода.

## Основные поверхности
ShadowChrome предлагает три ключевые поверхности, которые вместе формируют пользовательский опыт:

1. **Всплывающее окно (`popup.html` / `popup.js`)** — интерфейс для импорта access key, выбора сервера и управления соединением.
2. **Страница параметров (`options.html` / `options.js`)** — консоль для работы с реестром доменов, сохраненными серверами, синхронизацией Outline, диагностикой и локализацией.
3. **Фоновый сервис-воркер (`background.js`)** — долгоживущий процесс, который запускает клиент Shadowsocks, управляет прокси, координирует фоновые синхронизации и обрабатывает сообщения из интерфейсов.

Каждая поверхность максимально статична: при загрузке UI-файлы читают данные из `chrome.storage.local`, а намерения передают воркеру через `chrome.runtime.sendMessage`. Так чувствительные операции остаются внутри воркера, а всплывающее окно не подвисает.

## Жизненный цикл
Рабочий цикл выглядит так:

1. **Восстановление.** При открытии всплывающее окно считывает языковые предпочтения, сохраненные серверы и текущий статус прокси.
2. **Импорт access key.** Ключ передается в `ssConfig.js`, где нормализуются ссылки и подписки, выполняется дедупликация через `ServerStore`, и данные становятся доступны интерфейсам.
3. **Запрос на подключение.** Выбор сервера и кнопка **Connect** создают сообщение `{type: 'start-proxy', config}` для сервис-воркера.
4. **Активация прокси.** Воркер запускает клиент Shadowsocks, привязывает его к `127.0.0.1:<порт>`, применяет настройки прокси Chrome и возвращает статус в интерфейс.
5. **Мониторинг и резерв.** При сбоях используются кэшированные резервные серверы CensorTracker. Воркер пробует их по очереди, пока подключение не восстановится или пул не закончится.
6. **Отключение.** По требованию пользователя или при ошибке отправляется `{type: 'stop-proxy'}`. Воркер останавливает клиент, сбрасывает прокси и обновляет сохраненный статус.

Диаграммы последовательностей и тайминги — в [`docs/architecture/workflows.md`](architecture/workflows.md).

## Структура исходников
Весь код лежит в `src/`. Ниже перечислены основные точки входа и их назначение:

```text
src/
├─ background.js              # Сервис-воркер: прокси, PAC и клиент Shadowsocks
├─ browser-api.js             # Обертка над браузерным API с промисами
├─ censortracker.js           # Работа со встроенными данными CensorTracker и обновлениями
├─ censortrackerServer.js     # Синхронизация с удаленными узлами CensorTracker
├─ censortracker-domains.json # Встроенный доменный список
├─ diagnostics.js             # Сбор диагностической информации
├─ logger.js                  # Минимальный логгер
├─ manifest.json              # Манифест MV3 с разрешениями и сервис-воркером
├─ outlineManager.js          # Синхронизация ключей Outline Manager
├─ pac.js                     # Генерация PAC-скриптов
├─ popup.html                 # Разметка всплывающего окна
├─ popup.js                   # Логика всплывающего окна
├─ options.html               # Разметка страницы параметров
├─ options.js                 # Логика страницы параметров
├─ proxyManager.js            # Применение PAC и настроек прокси
├─ registry.js                # Работа с доменным реестром для PAC
├─ serverClient.js            # Загрузка удаленных конфигураций и доменных списков
├─ serverStore.js             # Хранилище конфигураций Shadowsocks
├─ ssConfig.js                # Парсер access keys и подписок
├─ integrations/              # Метаданные шифров и вспомогательные модули
├─ utils/fetchWithTimeout.js  # Обертка над fetch с таймаутами под MV3
└─ utils/withTimeout.js       # Общая промис-обертка с таймаутом
```

Взаимосвязи модулей подробно описаны в [`docs/architecture/components.md`](architecture/components.md).

## Компоненты подробнее

### popup.html / popup.js

Всплывающее окно остается минималистичным и отвечает только за управление соединением:

- **Переключатель языка** синхронизируется со страницей параметров, чтобы менять переводы без закрытия окна.
- **Форма для access key** импортирует подписки, сохраняет серверы и скрывается после успешного ввода.
- **Селектор локаций** отображает сохраненные серверы и сортирует их по минимальной задержке.
- **Connect** и **Disconnect** запускают и останавливают клиент.
- **Change access key** заново открывает форму импорта.
- **Иконка настроек** открывает страницу параметров в новой вкладке.
- **Строка состояния** (`#status`) сообщает о текущем состоянии прокси, попытках fallback и ошибках через `aria-live`.

Ключевые обработчики в `popup.js`:

- `DOMContentLoaded` — восстанавливает язык и последний access key, подтягивает серверы и актуальный статус.
- **Import access key** — разбирает URL доступа, сохраняет конфигурации в `ServerStore` и сворачивает форму.
- **Connect** — запускает прокси для выбранного сервера, при необходимости добавляя его в хранилище.
- **Disconnect** — отправляет `stop-proxy` сервис-воркеру.
- **Change access key** — открывает форму для новой подписки.
- **Open settings** — вызывает `browser.runtime.openOptionsPage()`.

Все сетевые операции выполняются в сервис-воркере, поэтому всплывающее окно не держит долгих соединений.

### options.html / options.js

Страница параметров объединяет продвинутые инструменты:

- **Переключатель языка** хранит выбор между всплывающим окном и страницей параметров.
- **Инструменты access key** позволяют импортировать подписки и удалять сохраненные серверы.
- **Редактор доменов** включает переключатель CensorTracker, списки пользовательских доменов и исключений с инлайновым удалением.
- **Каталог saved servers** показывает каждую конфигурацию с действиями **Use** и **Remove**.
- **Форма Outline Manager** регистрирует endpoints, запускает синхронизацию и поддерживает указание SHA-256 fingerprint.
- **Кнопка Sync** по очереди обновляет зеркала, синхронизирует Outline и загружает CensorTracker, отчеты выводятся в строку статуса.
- **Кнопка Diagnostics** возвращает JSON со сведениями для поддержки.
- **Контекстная справка** оформлена через `<details class="help">` с заголовком «Learn more» и переводит технические термины на понятный язык.

`options.js` использует общую карту переводов с popup, слушает изменения `ServerStore`, чтобы обновлять список серверов, и общается с сервис-воркером через `browser.runtime.sendMessage`.

### ssConfig.js

Преобразует access keys Outline и Shadowsocks в объекты конфигурации рантайма.

#### parseAccessUrl(url)

- Использует портированную реализацию Outline `parseAccessKey`, чтобы различать статические `ss://` и подписки `ssconf://`/`https://`.
- Статические ключи разбираются через `parseSsUrl` и получают имя сервера из Outline, когда оно доступно.
- Подписки загружают удаленные JSON или текстовые документы через `fetchConfig`, сохраняя метаданные Outline.
- URL, которые не проходят парсер Outline, но начинаются с `http`/`https`, рассматриваются как подписки в режиме совместимости.

#### parseSsUrl(url, defaultTag?)

1. Удаляет префикс `ss://` и необязательный фрагмент `#tag`.
2. Декодирует остаток из Base64 или использует исходную строку, если декодирование не удалось.
3. Вложенные URL (`http`, `https`, `ssconf://`) воспринимаются как подписки и отправляются в `fetchConfig`.
4. Делит строку на `<method>:<password>@<host>:<port>` и восстанавливает пароль вспомогательной функцией.
5. Применяет метку Outline `defaultTag`, если URL не содержит собственный тег, и пишет предупреждение, когда шифр вне набора AEAD из `integrations/shadowsocksCiphers.js`.

#### fetchConfig(onlineUrl, defaultTag?)

1. Загружает удаленный документ и при необходимости декодирует Base64.
2. Поддерживает наборы данных: строки `ss://`, разделенные переводами строки, и JSON с массивами или объектами `servers`, `configs` и вложенными `accessUrl`.
3. Рекурсивно разворачивает вложенные access keys, передавая теги Outline в возвращаемые конфигурации.
4. Возвращает массив нормализованных объектов, готовых к сохранению и подключению.

### background.js

- Хранит `proxyConfig` активного сервера.
- `setChromeProxy(config, sendResponse)` оборачивает `chrome.proxy.settings.set` и возвращает ошибки в интерфейс.
- `chrome.runtime.onMessage.addListener` обрабатывает:
  - `start-proxy` — сохраняет конфигурацию, запускает клиент и применяет прокси.
  - `stop-proxy` — останавливает клиент, очищает прокси и сбрасывает `proxyConfig`.
  - `sync` — запускает обновление зеркал.
  - `sync-censortracker` — обновляет конфигурацию CensorTracker, реестр и список исключений.
  - `sync-outline` — вызывает `OutlineManager.syncAll()`.
  - `add-outline-manager` — сохраняет метаданные и пытается синхронизироваться сразу, возвращая предупреждение при сбое.
  - `list-outline-managers` / `remove-outline-manager` — управляет менеджерами Outline и удаляет связанные сервера через `ServerStore.removeByManager`.
  - `list-servers` / `remove-server` — обслуживает каталог сохраненных серверов.
  - `get-registry-state` / `set-registry-enabled` — передает состояние реестра всплывающему окну и переключает его.
  - `add-ignored-domain` / `remove-ignored-domain` — управляет списком обхода, который использует генератор PAC.
  - `get-diagnostics` — собирает диагностические данные.
  - `get-proxy-status` — возвращает `{running, summary}`, чтобы интерфейс мог показать состояние.
- Клиент Shadowsocks использует `chrome.sockets.tcp` с AES-256-GCM для шифрования трафика прямо в сервис-воркере.

### manifest.json

Объявляет сервис-воркер MV3 и необходимые разрешения:

- `proxy` — изменение прокси-настроек Chrome.
- `storage` — работа с хранилищем.
- `sockets` — запуск TCP-клиента.
- `host_permissions: <all_urls>` — загрузка удаленных подписок.

### registry.js

Управляет составным доменным реестром, который использует генератор PAC. Модуль объединяет три источника:

- Встроенные домены CensorTracker, сохраненные в `domainRegistry`.
- Пользовательские домены, добавленные вручную.
- Список исключений, позволяющий обходить прокси для отдельных хостов.

Публичные методы предоставляют операции CRUD для пользовательских и игнорируемых доменов, переключают использование реестра и возвращают метаданные (источник, страна, время синхронизации) для интерфейса. Любое изменение вызывает слушателей, после чего PAC пересобирается автоматически.


## 8. Что хранит расширение
ShadowChrome сохраняет состояние только в `chrome.storage.local` вашего профиля:

- `accessUrl` — последний использованный access key.
- `lastConfig` — очищенная конфигурация, переданная сервис-воркеру.
- `servers` — список серверов Shadowsocks из ручного импорта и Outline Manager.
- `domainRegistry` — домены, которые использует генератор PAC.
- `registryState` — настройки пользователя, список исключений, сведения о синхронизации и кэш резервных серверов CensorTracker.
- `censortrackerFallback` — последние резервные серверы, информация о провайдере и временные метки.
- `outlineManagers` — зарегистрированные менеджеры Outline.
- `logs` — буфер логов фонового процесса.

Удаление расширения из Chrome очищает все значения. Никакие данные не покидают профиль браузера.

## 9. Быстрый чек-лист по диагностике

1. **Ошибка появляется сразу после подключения.** Проверьте, что access key действителен и использует поддерживаемый шифр. Всплывающее окно показывает сообщение сервис-воркера.
2. **Не отображаются серверы Outline.** Нажмите **Sync**, чтобы обновить список, и убедитесь, что API Outline доступен.
3. **PAC работает странно.** Проверьте доменные списки. Правила применяются автоматически сразу после изменений.
4. **Diagnostics возвращает пустой результат.** Сервис-воркер мог выгрузиться. Откройте всплывающее окно, чтобы перезапустить его.
5. **Постоянно активируется fallback.** Вероятно, основной ключ устарел. Импортируйте свежую подписку или уточните статус серверов у провайдера.

## 10. Что изучить дальше

- Загляните в английскую версию [`docs/DETAILED_DOCUMENTATION.md`](DETAILED_DOCUMENTATION.md), если хотите сравнить формулировки и оригинальные термины.
- Загляните в [`docs/architecture/`](architecture/), где собраны диаграммы последовательностей и подробный разбор компонентов.
- Перед тем как делиться ShadowChrome с коллегами или тестировщиками, обязательно прочитайте [Usage Policy](USAGE_POLICY.md).

## Доступность, локализация и UX

- **ARIA и объявления.** Строка статуса во всплывающем окне использует `aria-live="polite"`, поэтому вспомогательные технологии фиксируют изменения соединения без лишних прерываний.
- **Навигация с клавиатуры.** Элементы управления во всплывающем окне и на странице параметров расположены линейно и сфокусируются по табуляции, так что импорт ключей и запуск синхронизаций доступен без мыши.
- **Модель локализации.** Переводы хранятся в общих словарях, которыми пользуются обе поверхности интерфейса. Переключатель языка пишет выбор в `chrome.storage.local` и мгновенно перерисовывает активный документ.

## Границы безопасности и ограничения

- **Песочница браузера.** Весь сетевой трафик проходит через `chrome.sockets.tcp` внутри сервис-воркера. Нативный код не запускается, поэтому проект наследует гарантии песочницы Chrome.
- **Экспериментальный статус.** ShadowChrome не проходил внешний аудит для работы в враждебных средах. Используйте его для исследований, обучения и экспериментов. Формальные ожидания собраны в [`USAGE_POLICY.md`](USAGE_POLICY.md).
- **Нет автоматических обновлений.** Запуск из исходников означает, что обновления нужно подтягивать вручную и перезагружать расширение. Следите за репозиторием, чтобы не пропустить исправления.

## Разработка и тестирование

Проект использует ESLint для базовых проверок. Выполните:

```bash
npm install   # один раз
npm run lint
```

Весь код расширения расположен в `src/` и использует синтаксис ES-модулей. Линтер следит за стилем, но ручное тестирование интерфейса в Chrome по-прежнему рекомендуется после изменений.

## Аудит платформы 2025 года

Chrome 129 (стабильный релиз октября 2025) продолжает внедрение Manifest V3 без
ломающих удалений API для сетевых расширений. Во время ежегодного аудита мы
подтвердили актуальность ключевых допущений:

- Сервис-воркер фона использует только совместимые с Manifest V3 API из
  пространства `chrome` и событийную модель, не опираясь на устаревшие
  постоянные фоновые страницы.
- Маршрутизация прокси задействует `chrome.proxy.settings` и
  `chrome.sockets.tcp` — оба API поддерживаются в сборках 2025 года при наличии
  прав `proxy` и `sockets`.
- Динамические импорты в `background.js` и `options.js` согласованы с нынешним
  рантаймом Chrome, где доступен top-level `await` и потоковая загрузка модулей.
- Обновление политики Web Store от июля 2025 требует явных оговорок об
  ответственном использовании; добавленный [usage policy](USAGE_POLICY.md)
  покрывает это требование.

## Планы

- Добавить пиннинг сертификатов для синхронизации Outline Manager.
- Разрешить выбирать локальный порт и методы аутентификации.
- Написать автоматические тесты.
- Расширить проверки состояния без телеметрии, чтобы всплывающее окно
  предупреждало об устаревших access keys.

## Лицензия

MIT — см. [LICENSE](../LICENSE).
<!-- Updated: 2025-10-01 -->
